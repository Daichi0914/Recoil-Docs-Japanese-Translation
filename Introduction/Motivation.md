# 動機

互換性と単純さの理由から、外部のグローバル状態ではなく、Reactに組み込まれている状態(state)管理機能を使用することをお勧めします。

しかし、Reactにはいくつかの制限があります。

>* コンポーネントの状態は、共通の祖先に押し上げることによってのみ共有できますが、これには再レンダリングが必要な巨大なツリーが含まれる場合があります。
>* コンテキストは単一の値のみを格納でき、それぞれが独自のコンシューマを持つ値の不確定なセットは格納できません。
>* どちらの方法でも、木(ツリー)の上部(stateが存在しなければならない場所)と葉(stateが使用される場所)をコード分割するのは困難です。

APIとセマンティクスと振る舞いの両方を可能な限りReactらしく維持しながら、これを改善したいと考えています。

Recoilは、Reactツリーに直交するだけでなく、固有かつ添付(アタッチ)された[有向グラフ](https://www1.doshisha.ac.jp/~mjin/R/61/61.html)を定義します。
state変化は、このグラフの根(我々はatomと呼んでいます)から[純粋な関数](https://ykum4.com/243/)(selectorと呼んでいます)を通ってコンポーネントへと流れます。
この方法では、次のようになります。

>* 共有しているstateが、React local state(必要に応じてReducer等でカプセル化することができる)と同じ単純なget/setインターフェースを持つ、定型のないAPIを入手しました。
>* Concurrent Modeやその他のReactの新機能が利用可能になれば、それらと互換性を持つ可能性があります。
>* state定義は増分及び分散されているため、コード分割が可能です。
>* stateは、それを使用するコンポーネントを変更することなく、派生データで置き換えることができます。
>* 派生データは、それを使用するコンポーネントを変更することなく、同期と非同期の間で移動できます。
>* ナビゲーションは、linkにおけるstate遷移の符号化(エンコーディング)さえも、第一級の概念として扱うことができる。
>* 後方互換性のある方法でアプリケーションのstate全体を永続化するのは簡単なので、永続化されたstateはアプリケーションの変更に耐えることができます。